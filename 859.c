/*给定一组字符，使用原地算法将其压缩。

压缩后的长度必须始终小于或等于原数组长度。

数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。

在完成原地修改输入数组后，返回数组的新长度。



进阶：
你能否仅使用O(1) 空间解决问题？



示例 1：

输入：
["a","a","b","b","c","c","c"]

输出：
返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]

说明：
"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。
示例 2：

输入：
["a"]

输出：
返回1，输入数组的前1个字符应该是：["a"]

说明：
没有任何字符串被替代。
示例 3：

输入：
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

输出：
返回4，输入数组的前4个字符应该是：["a","b","1","2"]。

说明：
由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
注意每个数字在数组中都有它自己的位置。
*/
// 思路：遍历然后看看后面有几个一样的输出一样的就好了 思考超过10的数字 还有原地算法
//int compress(char* chars, int charsSize) {
//    for (int i = 0; i < strlen(chars); ++i) {
//        char tempChar = chars[i];
//        int temp = 0;
//
//    }
//}
/*给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。



示例 1：

输入： A = "ab", B = "ba"
输出： true
示例 2：

输入： A = "ab", B = "ab"
输出： false
示例 3:

输入： A = "aa", B = "aa"
输出： true
示例 4：

输入： A = "aaaaaaabc", B = "aaaaaaacb"
输出： true
示例 5：

输入： A = "", B = "aa"
输出： false


提示：

0 <= A.length <= 20000
0 <= B.length <= 20000
A 和 B 仅由小写字母构成。*/
// 思路：利用双指针遍历 判断B中的后面一个字符是否和A中的前一个字符相等 （index）
// 异常：长度不等直接返回false
// 欠缺：前两个符号后面的不符合了 不指交换两个 不交换的情况 前后字母一样的情况 不一定是连续的
// 更改思路：直接去找不相同的字母判断是否交换可以完成一样的效果
// 思路缺陷：缺少关于相同字符串的判断 如 aaa aaa
// 不会了。、。。。 改正：添加对于相同字符串的比较操作
// 网上的一些解释：
/*
1.长度不相等的两个字符串一定不可能满足条件。
2.两个完全相等的字符串，只要这个字符串由相同的字符，并且有重复的字符的话就是符合条件的。
3.对于两个长度相等的字符串，记录它们字符不相等的索引位置。如果不相等的字符的个数为2个而且满足交叉相等，则这样的字符串就是满足条件的。
*/
// 分成两个case想问题的话比较简单
// 1.完全相同的字符串
// 2.可以交换完成相同的字符串

#include "stdbool.h"
bool buddyStrings(char* A, char* B) {
    int len1=strlen(A),len2=strlen(B);
    if(len1!=len2)
        return false;
    if(len1<2)
        return false;
    int i,j,k,l=0;
    char tem,na[2],n=0;
    for(i=0,j=0;i<len1;i++,j++)
    {
        if(A[i]==B[j])
            continue;
        else
        {
            n++;
            if(n>2)
                return false;
            na[l]=i;
            l++;
        }

    }
//    不同字母的个数
    if(n==1)
        return false;
    if(n==2)
    {
//        判断不同的字母是否是岔开的
        if(A[na[1]]==B[na[0]]&&A[na[0]]==B[na[1]])
            return true;
        else
            return false;
    }
//    看看相同的字母里面是否是有重复的字母
    int aa[256]={0};
    for(i=0;i<len1;i++)
    {
        aa[A[i]]++;
        if(aa[A[i]]>=2)
            return true;
    }
    return false;
}
